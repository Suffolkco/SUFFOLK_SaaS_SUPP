using System;
using System.Collections.Generic;
using System.Configuration;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using log4net;
using Newtonsoft.Json;

namespace SIPSync
{
    internal class AAHelper
    {
        private static readonly ILog logger = LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
        private static HTTPHelper objHTTP = new HTTPHelper();

        //===================================================
        // Authenticate against the Accela Construct API 
        //===================================================
        public async Task<string> GetAccessToken()
        {
            logger.Info("Trying to get Construct access token.");

            try
            {
                var postContent = new Dictionary<string, string>
                {
                    ["client_id"] = ConfigurationManager.AppSettings["ConstructAppID"],
                    ["client_secret"] = ConfigurationManager.AppSettings["ConstructAppSecret"],
                    ["grant_type"] = "password",
                    ["username"] = ConfigurationManager.AppSettings["AccelaUserName"],
                    ["password"] = Decrypt(ConfigurationManager.AppSettings["AccelaPassword"]),
                    ["scope"] = "addresses agencies announcements app_data assessments assets batch_request civicid conditions contacts costs documents filters gis global_search inspections inspectors invoices mileage owners parcels parts payments professionals records reports run_emse_script run_generic_search settings timeaccounting users workflows",
                    ["agency_name"] = ConfigurationManager.AppSettings["ConstructAgency"],
                    ["environment"] = ConfigurationManager.AppSettings["ConstructEnvironment"]
                };

                string results = await objHTTP.FormPost(ConfigurationManager.AppSettings["ConstructTokenUri"], postContent);
                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);
                string access_token = parsedJson["access_token"];

                if (access_token != null) 
                { 
                    logger.Info("Successfully generated a Construct access token."); 
                } 
                else
                {
                    throw new Exception("Token was not generated by the call to the Contruct.");
                }
                
                return access_token;
            }
            catch (Exception ex)
            {
                logger.Error($"Unable to get Accela construct access token. The error is: {ex.Message}");
                return null;
            }
        }

        //===================================================
        // Retrieve encryption key securely from environment variable
        //===================================================
        private static string GetEncryptionKey()
        {
            string encryptionKey = Environment.GetEnvironmentVariable("ENCRYPTION_KEY");
            if (string.IsNullOrEmpty(encryptionKey))
            {
                throw new Exception("ENCRYPTION_KEY is not set in the environment variables.");
            }
            return encryptionKey;
        }

        //===================================================
        // Method to encrypt password
        //===================================================
        public string Encrypt(string clearText)
        {
            string encryptionKey = GetEncryptionKey();
            byte[] clearBytes = Encoding.Unicode.GetBytes(clearText);
            using (Aes encryptor = Aes.Create())
            {
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(encryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
                encryptor.Key = pdb.GetBytes(32);
                encryptor.IV = pdb.GetBytes(16);
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(clearBytes, 0, clearBytes.Length);
                        cs.Close();
                    }
                    clearText = Convert.ToBase64String(ms.ToArray());
                }
            }
            return clearText;
        }

        //===================================================
        // Method to decrypt password
        //===================================================
        public string Decrypt(string cipherText)
        {
            string encryptionKey = GetEncryptionKey();
            cipherText = cipherText.Replace(" ", "+");
            byte[] cipherBytes = Convert.FromBase64String(cipherText);
            using (Aes encryptor = Aes.Create())
            {
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(encryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
                encryptor.Key = pdb.GetBytes(32);
                encryptor.IV = pdb.GetBytes(16);
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        cs.Write(cipherBytes, 0, cipherBytes.Length);
                        cs.Close();
                    }
                    cipherText = Encoding.Unicode.GetString(ms.ToArray());
                }
            }
            return cipherText;
        }

        //===================================================
        // Retrieves record cap for given AltId 
        //===================================================
        public async Task<string> GetRecordCap(string altID)
        {
            try
            {
                string token = await GetAccessToken();
                if (string.IsNullOrEmpty(token)) throw new Exception("Access token is null or empty.");

                logger.Info("Trying to get record cap id for altId: " + altID);

                var headers = AddAuthHeader(token);
                string query = $"{ConfigurationManager.AppSettings["ConstructBaseUri"]}/v4/records/?customId={altID}";
                string results = (await objHTTP.HttpGet(query, headers)).Replace("\"[", "[").Replace("]\"", "]").Replace("\\", "");

                if (string.IsNullOrEmpty(results)) throw new Exception("Results from HTTP GET are null or empty.");

                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);
                string capId = parsedJson.result[0].id;

                if (string.IsNullOrEmpty(capId)) throw new Exception("Unable to find the requested record");

                logger.Info($"Got record capId as {capId}");
                return capId;
            }
            catch (Exception ex)
            {
                logger.Error($"Error in GetRecordCap: {ex.Message}");
                throw;
            }
        }

        //===================================================
        // Update custom field(s)
        //===================================================
        public async Task UpdateCustomFields(string cap, string groupSubgroupId, Dictionary<string, string> customFieldsValues)
        {
            try
            {
                if (string.IsNullOrEmpty(cap)) throw new Exception("No CAP provided");

                groupSubgroupId = groupSubgroupId.Replace(" ", ".c");
                string token = await GetAccessToken();
                if (string.IsNullOrEmpty(token)) throw new Exception("Cannot update custom field because no access token was generated.");

                var headers = AddAuthHeader(token);
                string query = $"{ConfigurationManager.AppSettings["ConstructBaseUri"]}/v4/records/{cap}/customForms";

                var asi = new Dictionary<string, string> { ["id"] = groupSubgroupId };
                foreach (var field in customFieldsValues) asi.Add(field.Key, field.Value);

                var asiList = new List<Dictionary<string, string>> { asi };
                string results = (await objHTTP.JSONRequest(query, asiList, "PUT", headers)).Replace("\"[", "[").Replace("]\"", "]").Replace("\\", "");

                if (string.IsNullOrEmpty(results)) throw new Exception("Unable to update custom fields.");

                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);

                if (parsedJson != null)
                {
                    string status = parsedJson.result[0].isSuccess;

                    if (!string.IsNullOrEmpty(status) && status == "True")
                    {
                        logger.Info($"Custom field data updated for CAPID {cap}");
                    }
                    else
                    {
                        throw new Exception($"Unable to update custom field data for CAPID {cap}");
                    }
                }

            }
            catch (Exception ex)
            {
                logger.Error($"Error in UpdateCustomFields: {ex.Message}");
                throw;
            }
        }

        //===================================================
        // Send Email
        //===================================================
        public async Task SendEmail(string toEmail, string emailBody)
        {
            try
            {
                if (string.IsNullOrEmpty(toEmail)) throw new Exception("No To Email provided");

                string token = await GetAccessToken();
                if (string.IsNullOrEmpty(token)) throw new Exception("Cannot send email via Accela because not To Email was provided.");

                var headers = AddAuthHeader(token);
                string query = $"{ConfigurationManager.AppSettings["ConstructBaseUri"]}/v4/scripts/SEND_EMAIL";

                var emailInfo = new Dictionary<string, string>
                {
                    ["TOEMAIL"] = toEmail,
                    ["EMAILBODY"] = emailBody
                };

                logger.Info("Sending report email.");

                string results = (await objHTTP.JSONRequest(query, emailInfo, "POST", headers)).Replace("\"[", "[").Replace("]\"", "]").Replace("\\", "");

                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);

                if (parsedJson != null)
                {
                    
                    string status = parsedJson.status;

                    if (!string.IsNullOrEmpty(status) && status == "200")
                    {
                        logger.Info($"Email sent to {toEmail}");
                    }
                    else
                    {
                        throw new Exception($"Unable to send email to {toEmail}");
                    }
                }
            }
            catch (Exception ex)
            {
                logger.Error($"Error sending email via Accela: {ex.Message}");
                throw;
            }
        }

        //===================================================
        // Retrieves Workflow ID
        //===================================================
        public async Task<string> GetWorkflowID(string capId, string workflowDescription)
        {
            try
            {
                string token = await GetAccessToken();
                if (string.IsNullOrEmpty(token)) throw new Exception("Access token is null or empty.");

                logger.Info("Trying to get workflow id");

                var headers = AddAuthHeader(token);
                string query = $"{ConfigurationManager.AppSettings["ConstructBaseUri"]}/v4/records/{capId}/workflowTasks";
                string results = (await objHTTP.HttpGet(query, headers)).Replace("\"[", "[").Replace("]\"", "]").Replace("\\", "");

                if (string.IsNullOrEmpty(results)) throw new Exception("Results from HTTP GET are null or empty.");

                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);
                string workflowId = null;

                foreach (var rec in parsedJson.result)
                {
                    if (rec.description == workflowDescription)
                    {
                        workflowId = rec.id;
                        break;
                    }
                }

                if (string.IsNullOrEmpty(workflowId)) throw new Exception("Unable to find the requested WorkflowID.");

                logger.Debug($"Got record WorkflowID as: {workflowId}");
                return workflowId;
            }
            catch (Exception ex)
            {
                logger.Error($"Error in GetWorkflowID: {ex.Message}");
                throw;
            }
        }

        //===================================================
        // Update Workflow Status
        //===================================================
        public async Task UpdateWorkflowStatus(string recordCapId, string workFlowName, string newStatus)
        {
            try
            {
                string workflow_id = await GetWorkflowID(recordCapId, workFlowName);
                var newTaskStatus = new WorkflowTask { status = new WorkflowTask.Status { text = newStatus, value = newStatus } };

                string token = await GetAccessToken();
                if (string.IsNullOrEmpty(token)) throw new Exception("Access token is null or empty.");

                var headers = AddAuthHeader(token);
                string query = $"{ConfigurationManager.AppSettings["ConstructBaseUri"]}/v4/records/{recordCapId}/workflowTasks/{workflow_id}";
                string results = (await objHTTP.JSONRequest(query, newTaskStatus, "PUT", headers)).Replace("\"[", "[").Replace("]\"", "]").Replace("\\", "");

                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);


                // {{
//                "result": {
//                    "lastModifiedDateString": "2024-06-04T13:01:31",
//    "processCode": "DEQ_SIP",
//    "lastModifiedDate": "2024-06-04 13:01:31",
//    "statusDate": "2024-06-04 12:00:57",
//    "serviceProviderCode": "SUFFOLKCO",
//    "isCompleted": "Y",
//    "isActive": "N",
//    "dueDateString": "2024-06-04T12:00:56",
//    "dueDate": "2024-06-04 12:00:56",
//    "skipIndicator": "000",
//    "description": "Payment Processing",
//    "id": "9-316",
//    "recordId": {
//                        "id": "SUFFOLKCO-SIPDC-00000-04716",
//      "trackingId": 0,
//      "capClass": "COMPLETE",
//      "missingIdentifier": false,
//      "customId": "G-22-09165",
//      "serviceProviderCode": "SUFFOLKCO",
//      "value": "SIPDC-00000-04716"
//    },
//    "actionbyUser": {
//                        "value": "INTERFACEUSER",
//      "text": "Interface User"
//    },
//    "status": {
//                        "value": "Complete",
//      "text": "Complete"
//    },
//    "currentTaskId": "019000000000000",
//    "nextTaskId": "000018000000000",
//    "daysDue": 0,
//    "hoursSpent": 0.0,
//    "billable": "N",
//    "overTime": "N",
//    "actionbyDepartment": {
//                        "value": "SUFFOLKCO/ADMIN/NA/NA/NA/NA/NA",
//      "text": "Administrator"
//    },
//    "assignedToDepartment": {
//                        "value": "SUFFOLKCO/DEQ/NA/NA/NA/NA/NA",
//      "text": "DEQ Admin"
//    },
//    "estimatedHours": 0.0
//                },
//  "status": 200
//}}


        logger.Debug($"Updated workflow status to {newStatus}");
            }
            catch (Exception ex)
            {
                logger.Error($"Error in UpdateWorkflowStatus: {ex.Message}");
                throw;
            }
        }

        //===================================================
        // Get CAP from Custom Field Search
        //===================================================
        public async Task<string> GetCAPFromCustomField(string field, string value)
        {
            try
            {
                string token = await GetAccessToken();
                if (string.IsNullOrEmpty(token)) throw new Exception("Access token is null or empty.");

                logger.Info($"Trying to get CAP from Custom Field ({field}) with a value of {value}.");

                var headers = AddAuthHeader(token);
                var asi = new Dictionary<string, string>
                {
                    ["CUSTOMFIELD"] = field,
                    ["CUSTOMFIELDVALUE"] = value
                };

                string query = $"{ConfigurationManager.AppSettings["ConstructBaseUri"]}/v4/scripts/GET_CAP_FROM_CUSTOMFIELD";
                string results = (await objHTTP.JSONRequest(query, asi, "POST", headers)).Replace("\"[", "[").Replace("]\"", "]").Replace("\\", "");

                dynamic parsedJson = JsonConvert.DeserializeObject<dynamic>(results);


                //"{\"status\":200,\"result\":{\"Response\":\"undefined\"}}"

                //if (string.)

                string cap = $"{parsedJson.result.Response.id1}-{parsedJson.result.Response.id2}-{parsedJson.result.Response.id3}";

                logger.Info($"Found a CAP of {cap}");

                return cap;
            }
            catch (Exception ex)
            {
                logger.Error($"Error in GetCAPFromCustomField: {ex.Message}");
                throw new Exception($"Unable to get {field}) with a value of {value}" );
            }
        }

        //===================================================
        // Authorization header creation
        //===================================================
        private static Dictionary<string, string> AddAuthHeader(string token)
        {
            return new Dictionary<string, string> { ["authorization"] = token };
        }

        //===================================================
        // Workflow class for statuses
        //===================================================
        public class WorkflowTask
        {
            public Status status { get; set; }

            public class Status
            {
                public string value { get; set; }
                public string text { get; set; }
            }
        }
    }
}
